## 初识签名
我第一次做 web3 IM Social 产品时，思考最多的问题，就是节点（服务器）凭什么给你（客户端）数据，这一点，和做 web2 产品有本质区别。  

做 web2 时，客户端想要什么数据，服务器就返回什么数据，web3 则不是你想要什么数据，就给你，而是，凭什么给你？

凭签名！

你在接入节点时，授权存入节点的数据，都用你的私钥进行了签名，你在提取数据时，也需要你的签名，节点签名验证过了，才会返回数据给你。

这样，就从技术上保证了，你的数据，只有你能看到，即使其他节点拿到了，他也解密不出来。

## 私钥就是你的一切

在 web2 电话号码就是你的一切，通过电话号码，你可以登录任何应用，忘记密码，你都可以找回账号。

在 web3 里，私钥就是你的一切，忘记了私钥，你就找不回你的数据，资产。

私钥通常由128位二进制数据组成，为了方便你记住这一串数据，通过 BIP39 协议，将 128位二进制数据，转换为 12 个单词，即：助记词，如：```voice true main glow spare magic you snack dress summer cherry cash```

通过私钥可以导出公钥，公钥和私钥是成对的，它们有 2 个作用：**加密解密**和**签名验签**。

私钥用于签名和解密消息，公钥用于验证数字签名和加密消息，数字签名用于确保消息的完整性和来源，以便接收方可以信任消息。

### 例子一：加密解密（公钥加密，私钥解密）

假设使用 coderlang 的公钥「```027951be58344fd7f2004e3c9c532562f976d0358700516d49a8ac68c5d83ba3b5```」对消息「```coderlang 34+ 程序员，CTO，全栈工程师，搬砖 11 年，薪资翻 20 倍，公众号 coderlang 主理人```」进行加密，即可得到加密过后的一长串密文数据，
而要解密该密文数据，只能通过公钥配对的私钥，进行解密，解密成功，即可得到原始消息。

我用 golang 写了 ![Test_Encrypt_Decrypt](https://github.com/coderlang/blockchain-expert/blob/master/signature/signature_test.go) 单元测试，测试数据如下：  
```shell
=== RUN   Test_Encrypt_Decrypt
PrivateKey:  c47a0fb020f2066223e049ea342c5ea9e9844da92b3101d37ae115d7f13380d8
PublicKey:  027951be58344fd7f2004e3c9c532562f976d0358700516d49a8ac68c5d83ba3b5
Msg:  coderlang 34+ 程序员，CTO，全栈工程师，搬砖 11 年，薪资翻 20 倍，公众号 coderlang 主理人
PublicKey Encrypt:  0489f50b457de2ae956e4b5917a285926f45be7399084b2063efb28063433ac59f0590e9f707da564f5d92eb01a13f890cb2d3bd3e014bde10b73f9ea99d45d145bfc24b114f417e6fe49fb0e3b814e4a9783bb3b78f5cadeb67c32e222ade78dc310bc7ebb046d22217ce8b1dbcd105240512a63d6e9cc1433b88c08b5129bb0244c0143d3f8279f09e4a162e1bff0ad967cd1747f08ea1950b2d816f8b1f8678bb008786d72b0a318476aeb48f6c866ccbc2a61c0fe421ba01551304e395f94d96447c8aeb80d6df0e47cf29f717bdd253af94fc7c4b8180c0ab757f698c2139ffbc
PrivateKey Decrypt:  coderlang 34+ 程序员，CTO，全栈工程师，搬砖 11 年，薪资翻 20 倍，公众号 coderlang 主理人
--- PASS: Test_Encrypt_Decrypt (0.00s)
```
代码如下：  
```go
func Test_Encrypt_Decrypt(t *testing.T) {
	var privateKeyHex = "c47a0fb020f2066223e049ea342c5ea9e9844da92b3101d37ae115d7f13380d8"
	
	privateKeyBytes, err := hex.DecodeString(privateKeyHex)
	if err != nil {
		t.Fatal(fmt.Sprintf("decode privateKey err %v", err))
		return
	}

	privateKey, err := crypto.ToECDSA(privateKeyBytes)
	if err != nil {
		t.Fatal(fmt.Sprintf("ToECDSA privateKey err %v", err))
		return
	}
	privateKeyECC := ecies.ImportECDSA(privateKey)

	println("PrivateKey: ", hex.EncodeToString(privateKeyECC.D.Bytes()))
	println("PublicKey: ", hex.EncodeToString(crypto.CompressPubkey(privateKeyECC.PublicKey.ExportECDSA())))

	msg := "coderlang 34+ 程序员，CTO，全栈工程师，搬砖 11 年，薪资翻 20 倍，公众号 coderlang 主理人"
	fmt.Println("Msg: ", msg)

	encrypt, err := ecies.Encrypt(rand.Reader, &privateKeyECC.PublicKey, []byte(msg), nil, nil)
	if err != nil {
		t.Fatal(err)
	}

	fmt.Println("PublicKey Encrypt: ", hex.EncodeToString(encrypt))

	decrypt, err := privateKeyECC.Decrypt(encrypt, nil, nil)
	if err != nil {
		t.Fatal(fmt.Sprintf("Decrypt err %v", err))
		return
	}

	if !bytes.Equal(decrypt, []byte(msg)) {
		t.Fatal("ecies: plaintext doesn't match message")
	}

	println("PrivateKey Decrypt: ", string(decrypt))
}
```

在 IM 消息场景里，我们就可以使用公钥私钥，对消息进行加解密，比如，张三想给 coderlang 发送加密消息，则可以使用 coderlang 的公钥进行加密，coderlang 收到加密消息，则通过自己的私钥进行解密，反过来，coderlang 给张三发加密消息，亦是如此。

这种设计，有一个问题，如果是群聊，一个 50 万的群，这样的加解密方式，势必导致通信效率降低，发一条消息，需要用群里的 50 万个成员公钥，进行加密，效率可想而知。

这时，我们就可以，通过将对称加密结合起来，公私钥加解密的不是消息本身，而是一个对称加密密钥，消息则用对称加密密钥进行加解密。

### 例子二：签名验签（私钥签名，公钥验签）

使用 coderlang 的私钥「```c47a0fb020f2066223e049ea342c5ea9e9844da92b3101d37ae115d7f13380d8```」对消息「```coderlang 34+ 程序员，CTO，全栈工程师，搬砖 11 年，薪资翻 20 倍，公众号 coderlang 主理人```」进行签名，
得到签名数据 Signature，接收方，根据 Signature 和 消息的Hash，进行验证，即可知道消息的真实性。

假设，有人在传输消息过程中，恶意将消息“搬砖 11 年，薪资翻 20 倍”更换成了“搬砖 11 年，薪资翻 200 倍”，那节点拿到 Signature 和错误消息 Hash，恢复出来的公钥，一定不是 coderlang 的公钥。

我用 golang 写了 ![Test_Encrypt_Decrypt](https://github.com/coderlang/blockchain-expert/blob/master/signature/signature_test.go) 单元测试，测试数据如下：
```shell

PrivateKey:  c47a0fb020f2066223e049ea342c5ea9e9844da92b3101d37ae115d7f13380d8
PublicKey:  027951be58344fd7f2004e3c9c532562f976d0358700516d49a8ac68c5d83ba3b5
Address:  0x301A70769871B16cA9c4E338c9515BdD7c79407D
Msg:  coderlang 34+ 程序员，CTO，全栈工程师，搬砖 11 年，薪资翻 20 倍，公众号 coderlang 主理人
Hash:  dee518afc392f58271028fc7a6961a3bb482c0b26cb076a81a6415b11957cbc9
Signature:  f5ea3d0a8958f34164339e70fa9451ec93a3a4490131d6e051c5d3b0c21d5efa7c776acfc3f8dccd8aa3fad88d43f190bc9b1cca927737ded808ccca1117066d01
SigToPub PublicKey:  027951be58344fd7f2004e3c9c532562f976d0358700516d49a8ac68c5d83ba3b5
InvalidMsg:  coderlang 34+ 程序员，CTO，全栈工程师，搬砖 11 年，薪资翻 200 倍，公众号 coderlang 主理人
InvalidSigToPub PublicKey:  03ebadb0dcf548321b14590141b4932f7cda18e35fffd771013da8a183c183921d
--- PASS: Test_Sign_Verify (0.00s)
```

代码如下：

```go
func Test_Sign_Verify(t *testing.T) {
	var privateKeyHex = "c47a0fb020f2066223e049ea342c5ea9e9844da92b3101d37ae115d7f13380d8"
	privateKeyBytes, err := hex.DecodeString(privateKeyHex)
	if err != nil {
		t.Fatal(fmt.Sprintf("decode privateKey err %v", err))
		return
	}

	privateKey, err := crypto.ToECDSA(privateKeyBytes)
	if err != nil {
		t.Fatal(fmt.Sprintf("ToECDSA privateKey err %v", err))
		return
	}
	publicKey := privateKey.PublicKey

	println("PrivateKey: ", hex.EncodeToString(privateKey.D.Bytes()))
	println("PublicKey: ", hex.EncodeToString(crypto.CompressPubkey(&publicKey)))
	println("Address: ", crypto.PubkeyToAddress(publicKey).Hex())
	// 要签名的数据
	msg := "coderlang 34+ 程序员，CTO，全栈工程师，搬砖 11 年，薪资翻 20 倍，公众号 coderlang 主理人"
	fmt.Println("Msg: ", msg)
	// 对数据进行哈希
	hash := crypto.Keccak256([]byte(msg))
	fmt.Println("Hash: ", hex.EncodeToString(hash))
	// 使用私钥对数据哈希进行签名
	signature, err := crypto.Sign(hash, privateKey)
	if err != nil {
		fmt.Println("Error signing data:", err)
		return
	}

	// 打印签名
	fmt.Println("Signature: ", hex.EncodeToString(signature))
	sigToPub, err := crypto.SigToPub(hash, signature)
	if err != nil {
		fmt.Println("Error SigToPub:", err)
		return
	}

	println("SigToPub PublicKey: ", hex.EncodeToString(crypto.CompressPubkey(sigToPub)))

	invalidMsg := "coderlang 34+ 程序员，CTO，全栈工程师，搬砖 11 年，薪资翻 200 倍，公众号 coderlang 主理人"
	fmt.Println("InvalidMsg: ", invalidMsg)
	invalidSigToPub, err := crypto.SigToPub(crypto.Keccak256([]byte(invalidMsg)), signature)
	if err != nil {
		fmt.Println("Error SigToPub:", err)
		return
	}
	println("InvalidSigToPub PublicKey: ", hex.EncodeToString(crypto.CompressPubkey(invalidSigToPub)))
}
```

签名验签，在 Web3 产品中，也有大量的应用，比如，登录授权，服务间调用权限验证，等等。

## 服务间调用

签名验证签名的应用

思考一个问题，你在做 web2 服务间调用是如何做的？我在 20 年，做一款产品，涉及众多服务，相互之前要调用。

因此，我们构建了一个统一认证服务中心 UnionAuth，如下图。

![UnionAuth.jpg](UnionAuth.jpg)
![UnionAuthTiming.jpg](UnionAuthTiming.jpg)

简单来说，所有服务，要相互通信，则需要在 UnionAuth 注册，由 UnionAuth分配 AppKey 和 SecretKey。

比如，Server1 要调用 signing machine 签名机器的接口，总共需要 8 步。

1,2: Server1 使用 AppKey、 SecretKey向 UnionAuth 请求访问 signing machine 的临时凭证 Ticket。  

3,6: Server1 拿到临时凭证 Ticket 登录signing machine，请求分配 Token。  

4,5: signing machine 拿到临时凭证 Ticket到 UnionAuth 验证，验证通过，则为 Server1颁发 Token  

8: Server1 拿到 Token，向客户端一样，开始请求signing machine接口。  

虽然，第 8 步，以后，Server1 可以访问signing machine，不在需要 UnionAuth，但当 Token 过期了，由需要从第 1 步开始执行。

这种方案，有一个问题，就是单机故障，只要 UnionAuth 服务挂了，整套系统，都回受到影响。

接下来，看一下，我们在 Web3，上是如何解决，这个问题的。

![NoUnionAuth.jpg](NoUnionAuth.jpg)
![NoUnionAuthTiming.jpg](NoUnionAuthTiming.jpg)

在 Web3上，不再需要 UnionAuth，则可以实现服务之间的安全访问，并且，只需要 3 步。

还是以 Server1访问 signing machine 签名机器服务。

1,2: Server1 用自己的私钥签名，和 signing machine 之间约定的通信，参数 X, signing machine 收到签名，则进行验证签名
验证通过，则返回 Token。

3：Server1 拿到 Token，向客户端一样，开始请求signing machine接口。


签名数据，被重放，则使用 nonce

### web2 怎么实现登录？


手机号+验证码，邮箱+验证码，服务器拿到手机号，邮箱，依靠数据库唯一索引，分配uid。




web3 不叫登录，叫授权，节点拿到，签名数据，即可通过签名，知道你的地址，而地址就是唯一的。


比如，dsyncle，使用助记词授权，


签名，是用私钥签的，私钥本质是，为了方便记住，因此，有了助记词。